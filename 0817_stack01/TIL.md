# DFS

---

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 이전 경로 저장은 스택이나 재귀함수로

- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

1. 시작 정점 v를 결정하여 방문한다.
2. 정점 v에 인접한 정점 중에서 
    
    - 방문하지 않은 정점 w가 있으면, 정점 v를 스택에 push하고 정점 w를 방문한다. 그리고 w를 v로 하여 다시2.를 반복한다.
    - 방문하지 않은 정점이 없으면 탐색의 방향을 바꾸기 위해 스택을 pop하여 받은 가장 마지막 방문 정점을 v로 하여 다시 2.를 반복한다.
    
3. 스택이 공백이 될 때 까지 2.를 반복한다.

---
## 방법
1. 초기상태 : 배열 visited를 False로 초기화 하고, 공백 스택을 생성
2. 정점 A를 시작으로 깊이 우선 탐색을 시작
```python
visited[A]  = True
```
3. 정점 A에 방문하지 않은 정점 B,C가 있으므로 A를 스택에 push하고 인접정점 B와 C중에서 오름차순에 따라 B를 선택하여 탐색을 계속
```python
push(a)
B방문
visited[B] = True
```
4. 정점 D에 방문하지 않은 정점 F가 있으므로 D를 스택에 push하고 인접 정점 F를 선택하여 탐색을 계속한다.
```python
push(F)
E방문
visited[E] = True
```
5. 정점 E에 방문하지 않은 정점 C가 있으므로 E를 스택에 push하고 인접정점 C를 선택하여 탐색을 계속한다.
```python
push(C)
```
6. 정점 C에 방문하지 않은 인접정점이 없으므로, pop
7. 정점 F에 방문하지 않은 인접정점이 없으므로, pop
8. 정점 F에 방문하지 않은 정점G가 있으므로 F를 스택에 push하고 인접정점 G를 선택하여 탐색을 계속한다.
```python
push(F)
G 방문
visited[G] = True
```
```python
adjlist = [[1,2],[0,3,4], [0,4],[1,5],[1,2,5],[3,4,6],[5]] # 0번째에 1,2 1번째에 0,3,4 위치 인접!!!
def dfs(v,N):
        visited = [0] * N   # visited 생성
        stack = [0] * N     # stack 생성
        top = -1            
        
       visited[v] = 1 #시작점 방문 표시
       while True:
           for w in adjlist[v]: #if ( v의 인접 정점 중 방문 안 한 정점 w가 있으면)
               if visited[w] == 0:
                    top += 1   # v -< w
                    stack[top] = v
                    v = w               # w에 방문
                    visited[w] = 1#visited[w] <- true
                    print(v)   # 방문
                    break
           else:   # w가 없으면 
               if top != -1:         #스택이 비어있지 않은 경우
                    v = stack[top]  #pop
                   top -= 1
                else :     
                    break
dfs(1, 7)
```
1. 인접리스트 만들기
2. 방문 리스트 만들기 visted = [0] * n 시작점 고르고 
3. DFS시작 -> 방문처리, 인접한 점 중에서 방문할 수 있는 방문가능한 정점 찾기
4. 방문가능하면 stack에 넣고 방문
5. 방문 불가능하면 stack에서 pop을 하고 


시작정점부터 DFS 시작
인접리스트 확인
stack에 넣고 이동
인접 list

visited 만들기

깊이우선. 무조건 동작 이해 우선

